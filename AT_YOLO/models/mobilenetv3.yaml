# YOLOv5 🚀 by Ultralytics, GPL-3.0 license

# Parameters
nc: 6  # number of classes
#depth_multiple和width_multiple越大，表示该网络结构越复杂，检测的精准度越高，但是训练检测速度会越来越慢。 可以去对比一下yolov5的几个尺寸，他们就在这儿有不同。
depth_multiple: 1.0  # model depth multiple  模型深度倍数
width_multiple: 1.0  # layer channel multiple      通道倍数   （因为输出的特征通道越多则越宽，所以是叫宽度倍数）
anchors:
  - [10,13, 16,30, 33,23]  # P3/8 低层      #在地层下定义了三个anchor 分别是10×13、16×30、33×23
  - [30,61, 62,45, 59,119]  # P4/16 中层
  - [116,90, 156,198, 373,326]  # P5/32 高层

   # Mobilenetv3-small backbone
   # MobileNetV3_InvertedResidual [out_ch, hid_ch, k_s, stride, SE, HardSwish]
backbone:
  # [from, number, module, args]  这四个值分别是来源、模块个数、该层的模块层、参数          #后面的p1，p2，p3，p4，p5表示五层金字塔结构 。  p1后面的的数表示缩小倍数。           #不同的层模块都在models下的common.py文件中有定义
  [[-1, 1, Conv_BN_HSwish, [16, 2]],                              # 0-p1/2    from为-1 表示该层（即第0层）是从上一层来的  。 number为1，表示有一个Conv_BN_HSwish        #第0层是金字塔第一层 经过一个步长为2的卷积后（eg：输入的图片尺寸由640×640变成了320×320），尺寸缩小了一半，类似于除以2  #输出的特征通道数为16 （实际是16乘以width_multiple）
   [-1, 1, MobileNetV3_InvertedResidual, [16,  16, 3, 2, 1, 0]],  # 1-p2/4           #同样的p2/4 是第二层的金字塔经过一个步长为2的卷积后，是原先输入图片尺寸的四分之一了。以此类推
   [-1, 1, MobileNetV3_InvertedResidual, [24,  72, 3, 2, 0, 0]],  # 2-p3/8
   [-1, 1, MobileNetV3_InvertedResidual, [24,  88, 3, 1, 0, 0]],  # 3
   [-1, 1, MobileNetV3_InvertedResidual, [40,  96, 5, 2, 1, 1]],  # 4-p4/16
   [-1, 1, MobileNetV3_InvertedResidual, [40, 240, 5, 1, 1, 1]],  # 5
   [-1, 1, MobileNetV3_InvertedResidual, [40, 240, 5, 1, 1, 1]],  # 6
   [-1, 1, MobileNetV3_InvertedResidual, [48, 120, 5, 1, 1, 1]],  # 7
   [-1, 1, MobileNetV3_InvertedResidual, [48, 144, 5, 1, 1, 1]],  # 8
   [-1, 1, MobileNetV3_InvertedResidual, [96, 288, 5, 2, 1, 1]],  # 9-p5/32
   [-1, 1, MobileNetV3_InvertedResidual, [96, 576, 5, 1, 1, 1]],  # 10
   [-1, 1, MobileNetV3_InvertedResidual, [96, 576, 5, 1, 1, 1]],  # 11
  ]


# YOLOv5 v6.0 head
head:
  [[-1, 1, Conv, [96, 1, 1]],  # 12
   [-1, 1, nn.Upsample, [None, 2, 'nearest']],            #Upsample是上采样
   [[-1, 8], 1, Concat, [1]],  # cat backbone P4      #Concat是拼接        #from中的[-1， 8] 中的-1和8表示是从上一层和第8层来的
   [-1, 3, C3, [144, False]],  # 15                number为3，表示为有3个C3的模块层，不过最后不一定是3个，还得看depth_multiple深度倍数 （即3乘以depth_multiple）

   [-1, 1, Conv, [144, 1, 1]], # 16
   [-1, 1, nn.Upsample, [None, 2, 'nearest']],
   [[-1, 3], 1, Concat, [1]],  # cat backbone P3
   [-1, 3, C3, [168, False]],  # 19 (P3/8-small)    #低层  用于检测小目标

   [-1, 1, Conv, [168, 3, 2]],
   [[-1, 16], 1, Concat, [1]], # cat head P4
   [-1, 3, C3, [312, False]],  # 22 (P4/16-medium)        #中层       用于检测中目标

   [-1, 1, Conv, [312, 3, 2]],
   [[-1, 12], 1, Concat, [1]], # cat head P5
   [-1, 3, C3, [408, False]],  # 25 (P5/32-large)            #高层          用于检测大目标

   [[19, 22, 25], 1, Detect, [nc, anchors]],  # Detect(P3, P4, P5)
  ]